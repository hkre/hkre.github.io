<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>synchronized</title>
    <link href="/2022/10/28/202210/synchronized/"/>
    <url>/2022/10/28/202210/synchronized/</url>
    
    <content type="html"><![CDATA[<blockquote><h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1></blockquote><h1 id="1-synchronized的定义"><a href="#1-synchronized的定义" class="headerlink" title="1:synchronized的定义"></a>1:synchronized的定义</h1><h2 id="1-1synchronized的使用形式"><a href="#1-1synchronized的使用形式" class="headerlink" title="1.1synchronized的使用形式"></a>1.1synchronized的使用形式</h2><h3 id="1-1-1三种使用形式"><a href="#1-1-1三种使用形式" class="headerlink" title="1.1.1三种使用形式"></a>1.1.1三种使用形式</h3><ul><li><input disabled type="checkbox"> 普通同步方法，锁的是当前实例对象</li><li><input disabled type="checkbox"> 静态同步方法,  锁的是当前类的Class对象</li><li><input disabled type="checkbox"> 同步代码块，锁的是synchronized括号</li></ul><blockquote><p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p><p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。</p><p><strong>不过两者的本质都是对对象监视器 monitor 的获取。</strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>synchronized</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发与并行</title>
    <link href="/2022/10/27/202210/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/"/>
    <url>/2022/10/27/202210/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<blockquote><h1 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h1></blockquote><h1 id="1-并发"><a href="#1-并发" class="headerlink" title="1:并发"></a>1:并发</h1><h2 id="1-1上下文切换"><a href="#1-1上下文切换" class="headerlink" title="1.1上下文切换"></a>1.1上下文切换</h2><p><em>cpu通过时间片来切换线程循环执行任务，jvm中的PC寄存器会记录上个线程执行的行数，以便下次从执行到的行数继续往下执行。</em></p><h4 id="1-1-1-减少上下文切换的开销"><a href="#1-1-1-减少上下文切换的开销" class="headerlink" title="1.1.1 减少上下文切换的开销"></a>1.1.1 减少上下文切换的开销</h4><ul><li><input disabled type="checkbox"> <em>无锁并发编程，数据的id安装Hash算法取模分段，不同线程处理不同段的数据</em></li><li><input disabled type="checkbox"> <em>CAS</em></li><li><input disabled type="checkbox"> <em>使用最少线程，干最多的事情，创建线程合理，避免大量线程处于等待状态</em></li><li><input disabled type="checkbox"> <em>协程</em></li></ul><h2 id="1-2：死锁"><a href="#1-2：死锁" class="headerlink" title="1.2：死锁"></a>1.2：死锁</h2><p><em>死锁是指两个线程执行过程中相关占用双方所需要的资源，导致两个线程都阻塞等待</em></p><h3 id="1-2-1-如何避免死锁"><a href="#1-2-1-如何避免死锁" class="headerlink" title="1.2.1:如何避免死锁"></a>1.2.1:如何避免死锁</h3><ul><li><p><input disabled type="checkbox"> <em>避免一个线程同时获多个锁</em></p></li><li><p><input disabled type="checkbox"> <em>避免一个线程在锁内占用多个资源，尽量保证每个锁只占用一个资源</em></p></li><li><p><input disabled type="checkbox"> <em>尝试使用定时锁，使用lock tryLock(timeout)来代替内部锁机制</em></p></li><li><p><input disabled type="checkbox"> <em>对于数据库锁，加锁与解锁必须在一个数据库连接里，否则会出现解锁失败的情况</em></p></li></ul><h2 id="1-3-volatile"><a href="#1-3-volatile" class="headerlink" title="1.3 volatile"></a>1.3 volatile</h2><h3 id="1-3-1轻量级的同步锁"><a href="#1-3-1轻量级的同步锁" class="headerlink" title="1.3.1轻量级的同步锁"></a>1.3.1轻量级的同步锁</h3><ul><li><p><input disabled type="checkbox"> <em>防止制定重排</em></p><blockquote><p><em>jvm在多线程环境下会对编译后的class文件进行优化选择执行，导致代码没有按照顺序执行</em></p></blockquote></li><li><p><input disabled type="checkbox"> <em>不能保证原子性</em></p><blockquote><p><em>不能像CAS机制一样，保证资源的被多个线程访问时的数据安全</em></p></blockquote></li><li><p><input disabled type="checkbox"> <em>对多个线程间保持透明</em></p><blockquote><p><em>多个线程访问一个资源时，一个线程改变资源后，其他线程可以获取修改后的值</em></p></blockquote></li></ul><h3 id="1-3-2实现原理"><a href="#1-3-2实现原理" class="headerlink" title="1.3.2实现原理"></a>1.3.2实现原理</h3><table><thead><tr><th>术语</th><th>英文单词</th><th>术语描述</th></tr></thead><tbody><tr><td><em>内存屏障</em></td><td><em>memory barriers</em></td><td><em>一组处理器指令，用于实现对内存操作的顺序限制。</em></td></tr><tr><td><em>缓冲行</em></td><td><em>cache line</em></td><td><em>缓存中可以分配的最小存储单位</em></td></tr><tr><td><em>原子操作</em></td><td><em>atomic operations</em></td><td><em>不可中断的一个或一系列操作</em></td></tr><tr><td><em>缓存行填充</em></td><td><em>cache line full</em></td><td><em>-当处理器识别到从内存中读取的操作数是可缓存的，处理器便读取整个缓冲行到适当缓存（L1、L2、L3…）。</em></td></tr><tr><td><em>缓存命中</em></td><td><em>cache hits</em></td><td><em>如果进行缓存的内存位置仍是下次处理器访问的地址时，处理器从缓存中读取，而不是内存。</em></td></tr><tr><td><em>写命中</em></td><td><em>write hit</em></td><td><em>要写的数据在缓存中，则直接写到缓存，而不是内存。</em></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h3 id="1-3-3-优化案例"><a href="#1-3-3-优化案例" class="headerlink" title="1.3.3 优化案例"></a>1.3.3 优化案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** 队列中的头部节点 */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> f?inal PaddedAtomicReference&lt;QNode&gt; head;<br><span class="hljs-comment">/** 队列中的尾部节点 */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> f?inal PaddedAtomicReference&lt;QNode&gt; tail;<br><span class="hljs-keyword">static</span> f?inal <span class="hljs-keyword">class</span> <span class="hljs-title class_">PaddedAtomicReference</span> &lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AtomicReference</span> T&gt; &#123;<br><span class="hljs-comment">// 使用很多4个字节的引用追加到64个字节</span><br>        Object p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pa, pb, pc, pd, pe;<br>        PaddedAtomicReference(T r) &#123;<br>        <span class="hljs-built_in">super</span>(r);<br>        &#125;<br>        &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicReference</span> &lt;V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> V value;<br><span class="hljs-comment">// 省略其他代码</span><br>｝<br><br></code></pre></td></tr></table></figure><ul><li><p><input disabled type="checkbox"> LinkedTransferQueue使用内部类PaddedAtomicReference来定义了头结点和尾巴节点。</p></li><li><p><input disabled type="checkbox"> 这个内部类做的事情就是把共享变量拓展追加了64个字节。父类变量4个字节，加上15个4字节的引用变量。</p></li><li><p><input disabled type="checkbox"> 因为对于大部分的处理器来说L1、L2、L3缓存的高速缓存行是64个字节宽。不支持部分填充缓存。如果队列的头结点和尾部节点都不是64个字节的话，那么他们就会被读到同一个高速缓存行。</p></li><li><p><input disabled type="checkbox"> 如果头结点和尾巴节点在同一个缓存行的时候，那么如果要修改头部节点，这个锁定了头部节点（MESI），而且尾部节点也在同一行，那么其他处理器是无法修改尾部节点的，问题是队列的入队和出队操作都是要修改头部和尾部节点，那么这个就会影响到队列的入队和出队的操作。</p></li><li><p><input disabled type="checkbox"> 所以要避免头结点和尾部节点加载到同一个缓存行。</p></li></ul><blockquote><p>下面的两种场景使用volatile变量时不需要追加到64字节。</p><ul><li>缓存行非64字节宽的处理器</li><li>共享变量不会被频繁地写，那么就没有必要读入那么多字节进缓存了。</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入了解一下JVM</title>
    <link href="/2022/10/26/202210/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/10/26/202210/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<blockquote><h1 id="深入了解一下JVM"><a href="#深入了解一下JVM" class="headerlink" title="深入了解一下JVM"></a>深入了解一下JVM</h1></blockquote><h2 id="1-什么是JVM"><a href="#1-什么是JVM" class="headerlink" title="1:什么是JVM"></a>1:什么是JVM</h2><h3 id="1-1一次编译，到处执行"><a href="#1-1一次编译，到处执行" class="headerlink" title="1.1一次编译，到处执行"></a>1.1一次编译，到处执行</h3><p><em>jvm又称java 虚拟机。用来将java语言与操作系统交互的桥梁，jvm将java文件编译成class文件，class文件是二进制语言，可以被机器执行。不同的操作系统有不同的jvm , 在任何平台上执行的java代码会被解释成一致的class文件，实现了一次编译，到处执行。</em></p><h2 id="2-什么是JMM"><a href="#2-什么是JMM" class="headerlink" title="2:什么是JMM"></a>2:什么是JMM</h2><h3 id="2-1java内存模型"><a href="#2-1java内存模型" class="headerlink" title="2.1java内存模型"></a>2.1java内存模型</h3><p>jmm又叫java内存模型。如图所示</p><p><img src="https://pic1.imgdb.cn/item/6359356c16f2c2beb1a7961a.png"></p><h3 id="2-2volatile"><a href="#2-2volatile" class="headerlink" title="2.2volatile"></a>2.2volatile</h3><blockquote><ul><li>volatile的底层原理其实就是通过lock信号和MESI协议通知所有的处理器缓存失效，并且把数据更新到了内存。</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基本配置</title>
    <link href="/2022/10/25/%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/10/25/%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>图床</td><td><a href="https://www.superbed.cn/timeline">https://www.superbed.cn/timeline</a></td></tr><tr><td>github账号</td><td><a href="mailto:&#50;&#52;&#x38;&#x36;&#49;&#x31;&#x38;&#54;&#50;&#55;&#64;&#113;&#113;&#46;&#99;&#111;&#109;">&#50;&#52;&#x38;&#x36;&#49;&#x31;&#x38;&#54;&#50;&#55;&#64;&#113;&#113;&#46;&#99;&#111;&#109;</a></td></tr><tr><td>github密码</td><td>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</td></tr><tr><td>github密码</td><td>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</td></tr><tr><td></td><td>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</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>博客基本配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客基本配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
